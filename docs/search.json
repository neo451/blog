[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "zztopia",
    "section": "",
    "text": "A guide to building in-process LSP in neovim: Part 2\n\n\n\nneovim\n\n\n\n\n\n\n\n\n\nDec 9, 2025\n\n\nZizhou Teng\n\n\n\n\n\n\n\n\n\n\n\n\nA guide to building in-process LSP in neovim: Part 1\n\n\n\nneovim\n\n\n\n\n\n\n\n\n\nNov 27, 2025\n\n\nZizhou Teng\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nNov 23, 2025\n\n\nZizhou Teng\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html",
    "href": "posts/in-process-lsp-guide2/index.html",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "",
    "text": "Got rather nice feedback from my first post, don’t want to lose the streak, so let’s do another one! It happens that I have been playing arround with implementing code action for obsidian.nvim and also working on a more fine-grained spell system for myself. Therefore, it makes perfect sense to add those improvements as code actions for the dict-lsp we worked on in part 1."
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#where-local-spellfile-goes",
    "href": "posts/in-process-lsp-guide2/index.html#where-local-spellfile-goes",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Where local spellfile goes",
    "text": "Where local spellfile goes\nThe idea is that we keep a local spellfile that is unique to a project, and whenever we open a new buffer, we try to find the spellfile.\nSo let’s take care of that first:\n---@param fname string\n---@return string?\nlocal function resolve_local_spellfile(fname)\n   local dir = vim.fs.root(fname, { \".git\", \".spell\" })\n\n   if not dir then\n      return\n   end\n\n   local spell_dir = vim.fs.joinpath(dir, \".spell\")\n   local stat = vim.uv.fs_stat(spell_dir)\n   if not stat or not stat.type == \"directory\" then\n      return\n   end\n\n   local path = vim.fs.joinpath(spell_dir, \".en.utf-8.add\")\n   if not vim.uv.fs_stat(path) then\n      vim.fn.writefile({}, path)\n      return\n   end\n   return path\nend\nRather easy to write with all the tools that neovim provides. Just note that I made it so that it will just silently fail if there’s no root marker, so if I want to add local dictionary for a project, I just go mkdir .spell, and it stays out of my way if I don’t want it."
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#understanding-vims-spellfile-system",
    "href": "posts/in-process-lsp-guide2/index.html#understanding-vims-spellfile-system",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Understanding vim’s spellfile system",
    "text": "Understanding vim’s spellfile system\ntldr: :h spellfile\nEssentially, spellfile is a list of comma separated paths local to buffer, that vim goes to check to show you spell check hints.\nThe key is a list of them, it was somehow not obvious to me why this is actually very useful and great design until I saw this post. So you can add a count to :spellgood or zg (and their wrong counterparts), and this count does not meaning what they usually mean how many times like in most vim motions, they are actually the index of the spellfile to use.\nI am guessing this is originally meant to solve how to add words to spellfile for different languages, but it also is perfect for having a local/global spellfile setup. We just assume whatever is the first spellfile is the global spellfile, and append the local file that we resolve based on the workspace to the end, and adding to global is :1spellgood word and adding to local is :{{last_index}}spellgood word"
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#implementing-the-logic",
    "href": "posts/in-process-lsp-guide2/index.html#implementing-the-logic",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Implementing the logic",
    "text": "Implementing the logic\nWe are using the same file of part 1 here, go check it out if you have not.\nlocal state {}\n\n---@param params lsp.DidOpenTextDocumentParams\nhandlers[ms.textDocument_didOpen] = function(params)\n   local fname = vim.uri_to_fname(params.textDocument.uri)\n   local local_speelfile = resolve_local_spellfile(fname)\n   if not local_speelfile then\n      return\n   end\n   vim.bo.spellfile = vim.bo.spellfile .. \",\" .. local_speelfile\n   state.local_spell_file_index = #vim.split(vim.bo.spellfile, \",\")\nend\n\n---@param buf integer\n---@return integer? client_id\nlocal function start_lsp(buf)\n   ---@type vim.lsp.ClientConfig\n   local client_cfg = {\n      name = \"dict-lsp\",\n      cmd = function()\n         return {\n            request = function(method, params, callback)\n               if handlers[method] then\n                  handlers[method](params, callback)\n                  return true\n               else\n                  return false\n               end\n            end,\n            notify = function(method, params, callback)\n               if handlers[method] then\n                  handlers[method](params, callback)\n                  return true\n               else\n                  return false\n               end\n            end,\n            is_closing = function() end,\n            terminate = function() end,\n         }\n      end,\n   }\n\n   return vim.lsp.start(client_cfg, { bufnr = buf, silent = false })\nend\nIn start_lsp function, we just copied the request handling to also handle notify, and add server capability textDocumentSync = true (shown later).\nThis didOpen notification handler is basically a glorified BufEnter autocmd at this point, I am kind of just doing it for the seek of it for you to get the idea.\nSo with this setup, you will have a second spellfile in any project that you have a .spell folder. And you can do zg to add to global, and 2zg to add to local. But we can use code action to sweeten everything up even more!"
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#code-action",
    "href": "posts/in-process-lsp-guide2/index.html#code-action",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Code Action",
    "text": "Code Action\nlocal commands = {\n   spell_good_local = {\n      desc = \"Add `%s` to local spellfile\",\n      fn = function(word)\n         if not state.local_spell_file_index then\n            vim.notify(\"no local spellfile available\")\n            return\n         end\n         vim.cmd(state.local_spell_file_index .. \"spellgood \" .. word)\n      end,\n   },\n   spell_good_global = {\n      desc = \"Add `%s` to global spellfile\",\n      fn = function(word)\n         vim.cmd(\"spellgood \" .. word) -- assume first is the global spellfile\n      end,\n   },\n}\n\nlocal chars = {}\nfor i = 32, 126 do\n   table.insert(chars, string.char(i))\nend\n\n---@type lsp.InitializeResult\nlocal initializeResult = {\n   capabilities = {\n      hoverProvider = true,\n      definitionProvider = true,\n      referencesProvider = true,\n      completionProvider = {\n         triggerCharacters = chars,\n      },\n      codeActionProvider = true, -- NOTE\n      executeCommandProvider = { commands = vim.tbl_keys(commands) }, -- NOTE\n      textDocumentSync = 1, -- NOTE\n   },\n   serverInfo = {\n      name = \"dict-lsp\",\n      version = \"0.0.1\",\n   },\n}\nFirst, we take care of the server capabilities like usual, it took me some while to find out that we need two providers enabled, one for code action and one for server commands.\nThe architecture is, there 2 things that a code action does, first optionally it will do a text edit, if you use LSP code action plugins, you will get a preview diff of that edit, then a code action can invoke a server command, to do more complex things, like modifying a workspace configuration file (in our case the spellfile). And being able to run server commands is considered another capability.\nThere’s a pretty clear division of labour between the two, code action will look at the current editor state, like the text you have selected or some other internal states, and give you a selected list of actions that is good to run. While executeCommandProvider just takes a command name and some arguments (in this case passed from code action), and go run the function.\nNow that we understand everything, we can finish our implementation.\n---@param params lsp.ExecuteCommandParams\n---@param callback fun(err?: lsp.ResponseError, result: any)\nhandlers[ms.workspace_executeCommand] = function(params, callback)\n   local word = unpack(params.arguments)\n\n   local ok, err = pcall(commands[params.command].fn, word)\n   if not ok then\n      ---@diagnostic disable-next-line: assign-type-mismatch\n      return callback({ code = 1, message = err }, {})\n   end\nend\n\n---@param _ lsp.CodeActionParams\n---@param callback function\nhandlers[ms.textDocument_codeAction] = function(_, callback)\n   local word = vim.fn.expand(\"&lt;cword&gt;\") -- NOTE: can get the visual selected word from params.range, but it seems to be a bit buggy when I tested\n   if not word then\n      return callback(nil, {})\n   end\n\n   local function new_action(cfg, command)\n      local title = cfg.desc:format(word)\n      return {\n         title = title,\n         command = { title = title, command = command, arguments = { word } },\n      }\n   end\n\n   local res = {}\n   for _, cmd_name in ipairs({ \"spell_good_local\", \"spell_good_global\" }) do\n      local config = commands[cmd_name]\n      res[#res + 1] = new_action(config, cmd_name) -- prettier title\n   end\n   callback(nil, res)\nend"
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#better-spell-correction",
    "href": "posts/in-process-lsp-guide2/index.html#better-spell-correction",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Better spell correction",
    "text": "Better spell correction\nJust when I was about to wrap this post up, and idea came to me that we can also dynamically register a few actions for correcting spelling. Both vim’s spellsuggest and the spell sources of picker plugins, only let us do correction, but now our code action interface can either add it to dictionary or change the spelling, much more general and intuitive. (basically what harper-ls offers)\nTurns out it is also very easy to do:\ncommands.spell_suggest = {\n   fn = function(index)\n      vim.api.nvim_feedkeys(index .. \"z=\", \"n\", false)\n   end,\n}\n\n---@param _ lsp.CodeActionParams\n---@param callback function\nhandlers[ms.textDocument_codeAction] = function(_, callback)\n   --- ...\n\n   if vim.fn.spellbadword(word)[1] ~= \"\" then\n      for _, cmd_name in ipairs({ \"spell_good_local\", \"spell_good_global\" }) do\n         local config = commands[cmd_name]\n         res[#res + 1] = new_action(config, cmd_name) -- prettier title\n      end\n      local suggests = vim.fn.spellsuggest(word, 3)\n      for idx, sug in ipairs(suggests) do\n         local title = (\"Change `%s` to `%s`\"):format(word, sug)\n         res[#res + 1] = {\n            title = title,\n            command = {\n               title = title,\n               command = \"spell_suggest\",\n               arguments = { idx },\n            },\n         }\n      end\n   end\n\n   callback(nil, res)\nend\nPlus it also makes sense to not even show any actions from this source if there’s no bad word under cursor, staying out of the way for other sources attached."
  },
  {
    "objectID": "posts/in-process-lsp-guide2/index.html#conclusion",
    "href": "posts/in-process-lsp-guide2/index.html#conclusion",
    "title": "A guide to building in-process LSP in neovim: Part 2",
    "section": "Conclusion",
    "text": "Conclusion\nThere’s still just a whole bunch of ways this idea can go, like completely bypass vim actions zg/zm, and just go do the textedit ourselves, so that user will get the preview that I mentioned before, but that is a bit too much for my taste.\nAnother thing I am considering is to inject some of these ideas into obsidian.nvim. Because obsidian uses a global user dictionary (also just a list of good words), I can temporarily append it to obsidian buffer’s spellfile option. On top of that, whenever user add new words into vim’s spellfile from a buffer in obsidian vault, obsidian.nvim can also add it to that global obsidian spellfile, so that user will have synced dictionary between vim and obsidian.\nOne thing I have learnt from the spellfile is to appreciate the beauty of “small flat list of anything”, because it is a flat list, it doesn’t have semantics, and the user can customize it to give the list their own meaning."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is where I rant!"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html",
    "href": "posts/in-process-lsp-guide/index.html",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "",
    "text": "I have spent quite some time turning most parts of the functionality of obsidian.nvim into an in-process LSP, and many folks have asked me how it compares to an actual LSP process running outside of neovim, or just wanted to get a general idea of what it means, since there aren’t not many good guides out there.\nBelow are my usual answers, and I intend to use this post with a concrete example project to give you an idea of how it works and why I think it is my favorite “black magic” feature of neovim:\n\nYou get neovim’s default LSP keymaps for free:\n\nYou get meaningful keymaps that most users are already using, and by default they are perfect keymaps to overload (expanded in Definition and References)\n\nYou get to leverage the vast ecosystem of plugins that enhance the LSP experience for free:\n\nFor example, inc-rename.nvim is just a better rename handler, and completion plugins like blink.cmp and nvim-cmp are essentially completion handlers, you don’t build integrations for all of these plugins with their APIs, you become the source of knowledge for them, thus being plugin agnostic\n\nYou let neovim do the heavy lifting logic for you:\n\nYou pass data to neovim’s well maintained hanlders to do things like renaming symbols in your workspace (trust me it will get messy if you do it yourself).\n\nYou get to “cheat” a bit than LSPs running as a system process:\n\nThey have to constantly keep negotiating with neovim about the document’s state, while you can just go vim.api.nvim_buf_get_lines"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#why-in-process-lsp",
    "href": "posts/in-process-lsp-guide/index.html#why-in-process-lsp",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "",
    "text": "I have spent quite some time turning most parts of the functionality of obsidian.nvim into an in-process LSP, and many folks have asked me how it compares to an actual LSP process running outside of neovim, or just wanted to get a general idea of what it means, since there aren’t not many good guides out there.\nBelow are my usual answers, and I intend to use this post with a concrete example project to give you an idea of how it works and why I think it is my favorite “black magic” feature of neovim:\n\nYou get neovim’s default LSP keymaps for free:\n\nYou get meaningful keymaps that most users are already using, and by default they are perfect keymaps to overload (expanded in Definition and References)\n\nYou get to leverage the vast ecosystem of plugins that enhance the LSP experience for free:\n\nFor example, inc-rename.nvim is just a better rename handler, and completion plugins like blink.cmp and nvim-cmp are essentially completion handlers, you don’t build integrations for all of these plugins with their APIs, you become the source of knowledge for them, thus being plugin agnostic\n\nYou let neovim do the heavy lifting logic for you:\n\nYou pass data to neovim’s well maintained hanlders to do things like renaming symbols in your workspace (trust me it will get messy if you do it yourself).\n\nYou get to “cheat” a bit than LSPs running as a system process:\n\nThey have to constantly keep negotiating with neovim about the document’s state, while you can just go vim.api.nvim_buf_get_lines"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#goal-of-this-guide",
    "href": "posts/in-process-lsp-guide/index.html#goal-of-this-guide",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Goal of this guide",
    "text": "Goal of this guide\nI have been enjoying using blink-cmp-words, which provides completion for words and synonyms when I write essays. However, I sometimes get frustrated for not being able to hover over a word and get what I had just seen in the documentation window when doing completion. So building it into an LSP is the perfect solution.\nFor the purpose of this guide, we will ignore all the details of actually querying the dictionary, and use various hacks and placeholders to get the idea across. I believe the eventual best solution would be using the same WordNet db approach that blink-cmp-words uses.\n\nThe complete example project as a gist\nIf you want to learn how “real” LSP servers work, see this video by tj"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#infrastructure",
    "href": "posts/in-process-lsp-guide/index.html#infrastructure",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Infrastructure",
    "text": "Infrastructure\n---@type table&lt;vim.lsp.protocol.Method, fun(params: table, callback:fun(err: lsp.ResponseError?, result: any))&gt;\nlocal handlers = {}\nlocal ms = vim.lsp.protocol.Methods\n\n---@param buf integer\n---@return integer? client_id\nlocal function start_lsp(buf)\n   ---@type vim.lsp.ClientConfig\n   local client_cfg = {\n      name = \"dict-lsp\",\n      cmd = function()\n         return {\n            request = function(method, params, callback)\n               if handlers[method] then\n                  handlers[method](params, callback)\n               end\n            end,\n            notify = function() end,\n            is_closing = function() end,\n            terminate = function() end,\n         }\n      end,\n   }\n\n   return vim.lsp.start(client_cfg, { bufnr = buf, silent = false })\nend\n\nvim.api.nvim_create_autocmd(\"FileType\", {\n   pattern = { \"markdown\", \"neorg\", \"org\", \"txt\" },\n   callback = function(ev)\n      start_lsp(ev.buf)\n   end,\n})\n\n\n\n\n\n\nNote\n\n\n\nNote that in theory after nvim-0.11 you could use vim.lsp.config which will be a bit more convenient, I just have not tried it and the improvements don’t concern the topic today.\n\n\nThe most important API to know is :h vim.lsp.start, it takes vim.lsp.ClientConfig and the two fields that concern us at the moment are:\n\nname: arbitrary name for the LSP client. Should be unique per language server.\ncmd: command string[] or function, and cmd in the case of in-process LSP will just be a function that returns a table of handlers, and we will only look into the request handler in this guide, as it handles most of the functionalities we think of when we think of LSP servers."
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#initializing-the-client-and-server",
    "href": "posts/in-process-lsp-guide/index.html#initializing-the-client-and-server",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Initializing the client and server",
    "text": "Initializing the client and server\nFirst time seeing the signature name vim.lsp.ClientConfig for those not familiar with neovim LSP might be somewhat confusing: weren’t we writing a server here? The answer is neovim spawns one LSP client per running server.\nAnd cmd is the recipe for the client to spawn the right LSP server, in this case, we don’t need to to run a new process, we just registered a function (that returns a table of method handlers) in memory.\nAfter spawning, the example above still will not work since our client and server have not negotiated a contract based on each other’s capabilities, usually this is a two way process, but since we are not an editor-agnostic server, we don’t really need to think about neovim’s client capabilities.\nWe only need neovim to know our server’s capabilities, which is done through responding to the initialize client request. Here’s a minimal example containing all the capabilities we will implement in this guide:\nlocal chars = {}\nfor i = 32, 126 do\n   table.insert(chars, string.char(i))\nend\n\n---@type lsp.InitializeResult\nlocal initializeResult = {\n   capabilities = {\n      hoverProvider = true,\n      definitionProvider = true,\n      referencesProvider = true,\n      completionProvider = {\n         triggerCharacters = chars,\n      },\n   },\n   serverInfo = {\n      name = \"dict-lsp\",\n      version = \"0.0.1\",\n   },\n}\n\nhandlers[ms.initialize] = function(_, callback)\n   callback(nil, initializeResult)\nend\nWith this handler setup, you should be able to open a markdown buffer, run checkhealth vim.lsp, and see our dict-lsp.\nvim.lsp: Active Clients ~\n- dict-lsp (id: 3)\n  - Version: 0.0.1\n  - Root directory: nil\n  - Command: &lt;function @/home/n451/Plugins/dict-lsp.nvim//lua/dict-lsp/init.lua:93&gt;\n  - Settings: {}\n  - Attached buffers: 13"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#hover",
    "href": "posts/in-process-lsp-guide/index.html#hover",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Hover",
    "text": "Hover\nLet’s try to implement what sets me out to write this guide, the hover.\n---@param _ lsp.HoverParams\n---@param callback fun(err?: lsp.ResponseError, result: lsp.Hover)\nhandlers[ms.textDocument_hover] = function(_, callback)\n   local word = vim.fn.expand(\"&lt;cword&gt;\")\n   local url_format = \"https://api.dictionaryapi.dev/api/v2/entries/en/%s\"\n\n   vim.system(\n      { \"curl\", url_format:format(word) },\n      vim.schedule_wrap(function(out)\n         local contents\n         if out.code ~= 0 then\n            contents = \"word fetch failed\"\n         else\n            local ok, decoded = pcall(vim.json.decode, out.stdout)\n            if ok and decoded and decoded[1] then\n               contents = decoded[1].meanings[1].definitions[1].definition\n            else\n               contents = decoded.message -- this api gives a nice message if no result\n            end\n         end\n         callback(nil, { contents = contents })\n      end)\n   )\nend\nIsn’t it amazing that now you get hover windows on words?\nTwo points worth noting:\n\nIn a “real” LSP server, we will need to get the current file and current cursor position from the params, and then it will need to compare its internal document state and compute the current word, but we get to “cheat” by just calling vim.fn.expand\"&lt;cword&gt;\", but I would suggest you don’t perform any actions that change the buffer and this is general principle for me when writing these in-process servers: we should think the document as mostly a read-only and immuntatble data, we only compute the data that is neccessary for neovim to performe actions.\nI basically copied the implementation to fetch the meaning from the returned json string, from none-ls.nvim’s dictionary source, there’s a even more powerful one to show you more detailed information about the word in hover.nvim’s dictionary provider, the later is pretty much a drag-in replacement."
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#definition-and-references",
    "href": "posts/in-process-lsp-guide/index.html#definition-and-references",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Definition and References",
    "text": "Definition and References\nLSP-related concepts forms a good mental map to restructure and conceptualize scattered pieces of actions, for example in obsidian.nvim, I had a revelation that everything from a tag to all kinds of links the plugin supports can just be thought of as symbols in LSP world that can be performed actions upon, and the two most important actions are goto definition and find references. (in obsidian jargon, it is linking and backlinking), quite like the idea that you can do all sorts of motions on different textobjects in vim.\nSo applying a similar logic, we can think goto definition in dictionary land could mean just finding the meaning of the word, and find references means looking up synonyms.\nMy initial idea for a complete implementation will look up the definitions and references, and then write a formatted page of markdown describing the meaning for each of the word in a tmp file, then return a list of lsp.Location pointing to them.\nBut since we did not implement WordNet queries, and the free dictionary API used above doesn’t provide a mechanism to look up synonyms, I came up with a rather fun and creative hack that kind of bypasses neovim’s handler pattern:\nhandlers[ms.textDocument_definition] = function()\n   local url = \"https://dictionary.cambridge.org/dictionary/english/%s\"\n   local word = vim.fn.expand(\"&lt;cword&gt;\")\n   vim.ui.open(string.format(url, word))\nend\n\nhandlers[ms.textDocument_references] = function()\n   local url = \"https://dictionary.cambridge.org/thesaurus/%s\"\n   local word = vim.fn.expand(\"&lt;cword&gt;\")\n   vim.ui.open(string.format(url, word))\nend\nBut I do think this is even better than actually querying, at least to me browser would make more sense to display a definition of a word.\nSome readers might ask if we did not use the params sent from client, and did not return anything to the client, instead, we only did an arbitrary side effect that is completely unrelated to LSP, what difference does it have compared to just binding the function to the keys like the following?\nvim.keymap.set(\"n\", \"grr\", function()\n   local url = \"https://dictionary.cambridge.org/thesaurus/%s\"\n   local word = vim.fn.expand(\"&lt;cword&gt;\")\n   vim.ui.open(string.format(url, word))\nend)\nThat leads us to the natural of “LSP keymaps” in neovim, in many ways they are special, many of them correspond to a vim.lsp.buf function, which will properly handle all the servers attached to one buffer and display results properly, for example multiple hover results will be shown together in the hover window, try making our little dict-lsp to also load in lua, and run some hovers if you have not seen multiple servers in action.\nThis nice feature makes “LSP keymaps” infinitely overloadable, you just add a server with the capability and corresponding handler, whereas the vim.keymap.set example will only ever run that one function in markdown."
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#completion",
    "href": "posts/in-process-lsp-guide/index.html#completion",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Completion",
    "text": "Completion\nCompletion is, in my opinion, the ultimate prize to win in the journey of in-process LSP, once I land lsp completion in obsidian.nvim, I will be able to deleted thousands of lines of lines of completion engine specific code that are messy to maintain. It also serves as a pretty satisfying concluding case for our little guide.\nThe following is basically an adaptation of none-ls’s spell source. Funny story is I have seen more than one person posting on r/neovim, saying they get unwanted words in their completion list, because none-ls.nvim list this source as a default example, and many forgot they left it there.\nThe reason this source is not very useful is that it uses vim’s native spellsuggest function to complete the word. I actually happened to find this paragraph describing the difference between a spell file and a dictionary in the help file today :h spell-file-format:\n\nNote that we avoid the word “dictionary” here. That is because the goal of spell checking differs from writing a dictionary (as in the book). For spelling we need a list of words that are OK, thus should not be highlighted. Person and company names will not appear in a dictionary, but do appear in a word list. And some old words are rarely used while they are common misspellings. These do appear in a dictionary but not in a word list.\n\nAs with all the cases above, we will need a capable local dictionary db or a paid dictionary API to really resolve this issue, but right now I think spell file approch is good enough for us, and I added fuzzy matching and filtering some unwanted cases to tidy up things a bit.\n---Adapted from none-ls\n---gets word to complete for use in completion sources\n---@param params lsp.CompletionParams\n---@return string word_to_complete\nlocal get_word_to_complete = function(params)\n   local col = params.position.character + 1\n   local line = vim.api.nvim_get_current_line()\n   local line_to_cursor = line:sub(1, col)\n   local regex = vim.regex(\"\\\\k*$\")\n\n   return line:sub(regex:match_str(line_to_cursor) + 1, col)\nend\n\n---@param params lsp.CompletionParams\n---@param callback fun(err?: lsp.ResponseError, result: lsp.CompletionItem[])\nhandlers[ms.textDocument_completion] = function(params, callback)\n   local word = get_word_to_complete(params)\n   local get_candidates = function(entries)\n      entries = vim.fn.matchfuzzy(entries, word, { limit = 7 })\n      local items = {}\n      for k, v in ipairs(entries) do\n         items[k] = { label = v, kind = vim.lsp.protocol.CompletionItemKind[\"Text\"] }\n      end\n\n      return vim.items\n   end\n\n   local candidates = get_candidates(vim.fn.spellsuggest(word)) -- a real implementation queries a dictionary here\n\n   candidates = vim.tbl_filter(function(candidate)\n      return candidate.label:find(\"[ ']\") == nil\n   end, candidates)\n\n   callback(nil, {\n      items = candidates,\n      isIncomplete = #candidates &gt; 0,\n   })\nend"
  },
  {
    "objectID": "posts/in-process-lsp-guide/index.html#conclusion",
    "href": "posts/in-process-lsp-guide/index.html#conclusion",
    "title": "A guide to building in-process LSP in neovim: Part 1",
    "section": "Conclusion",
    "text": "Conclusion\nThere you go, have fun exploring. I actually have a lot more ideas that I want to implement, but I will leave it here so that I can post it before I procrastinate over perfectionism. Maybe will write a part 2 if I have enough good ideas."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "TODO"
  }
]